{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { AbstractShape } from '@antv/g-base';\nimport { setShadow, setTransform, setClip } from '../util/svg';\nimport { createDom } from '../util/dom';\nimport { refreshElement } from '../util/draw';\nimport { SVG_ATTR_MAP } from '../constant';\nimport * as Shape from './index';\nimport Group from '../group';\nimport { getBBoxMethod } from '@antv/g-base';\nvar ShapeBase = /** @class */function (_super) {\n  __extends(ShapeBase, _super);\n  function ShapeBase() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = 'svg';\n    _this.canFill = false;\n    _this.canStroke = false;\n    return _this;\n  }\n  ShapeBase.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n    // 设置默认值\n    return __assign(__assign({}, attrs), {\n      lineWidth: 1,\n      lineAppendWidth: 0,\n      strokeOpacity: 1,\n      fillOpacity: 1\n    });\n  };\n  // 覆盖基类的 afterAttrsChange 方法\n  ShapeBase.prototype.afterAttrsChange = function (targetAttrs) {\n    _super.prototype.afterAttrsChange.call(this, targetAttrs);\n    var canvas = this.get('canvas');\n    // 只有挂载到画布下，才对元素进行实际渲染\n    if (canvas && canvas.get('autoDraw')) {\n      var context = canvas.get('context');\n      this.draw(context, targetAttrs);\n    }\n  };\n  ShapeBase.prototype.getShapeBase = function () {\n    return Shape;\n  };\n  ShapeBase.prototype.getGroupBase = function () {\n    return Group;\n  };\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n  ShapeBase.prototype.onCanvasChange = function (changeType) {\n    refreshElement(this, changeType);\n  };\n  ShapeBase.prototype.calculateBBox = function () {\n    var el = this.get('el');\n    var bbox = null;\n    // 包围盒计算依赖于绘制，如果还没有生成对应的 Dom 元素，则包围盒的长宽均为 0\n    if (el) {\n      bbox = el.getBBox();\n    } else {\n      var bboxMethod = getBBoxMethod(this.get('type'));\n      if (bboxMethod) {\n        bbox = bboxMethod(this);\n      }\n    }\n    if (bbox) {\n      var x = bbox.x,\n        y = bbox.y,\n        width = bbox.width,\n        height = bbox.height;\n      var lineWidth = this.getHitLineWidth();\n      var halfWidth = lineWidth / 2;\n      var minX = x - halfWidth;\n      var minY = y - halfWidth;\n      var maxX = x + width + halfWidth;\n      var maxY = y + height + halfWidth;\n      return {\n        x: minX,\n        y: minY,\n        minX: minX,\n        minY: minY,\n        maxX: maxX,\n        maxY: maxY,\n        width: width + lineWidth,\n        height: height + lineWidth\n      };\n    }\n    return {\n      x: 0,\n      y: 0,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width: 0,\n      height: 0\n    };\n  };\n  ShapeBase.prototype.isFill = function () {\n    var _a = this.attr(),\n      fill = _a.fill,\n      fillStyle = _a.fillStyle;\n    return (fill || fillStyle || this.isClipShape()) && this.canFill;\n  };\n  ShapeBase.prototype.isStroke = function () {\n    var _a = this.attr(),\n      stroke = _a.stroke,\n      strokeStyle = _a.strokeStyle;\n    return (stroke || strokeStyle) && this.canStroke;\n  };\n  ShapeBase.prototype.draw = function (context, targetAttrs) {\n    var el = this.get('el');\n    if (this.get('destroyed')) {\n      if (el) {\n        el.parentNode.removeChild(el);\n      }\n    } else {\n      if (!el) {\n        createDom(this);\n      }\n      setClip(this, context);\n      this.createPath(context, targetAttrs);\n      this.shadow(context, targetAttrs);\n      this.strokeAndFill(context, targetAttrs);\n      this.transform(targetAttrs);\n    }\n  };\n  /**\n   * @protected\n   * 绘制图形的路径\n   * @param {Defs} context 上下文\n   * @param {ShapeAttrs} targetAttrs 渲染的目标属性\n   */\n  ShapeBase.prototype.createPath = function (context, targetAttrs) {};\n  // stroke and fill\n  ShapeBase.prototype.strokeAndFill = function (context, targetAttrs) {\n    var attrs = targetAttrs || this.attr();\n    var fill = attrs.fill,\n      fillStyle = attrs.fillStyle,\n      stroke = attrs.stroke,\n      strokeStyle = attrs.strokeStyle,\n      fillOpacity = attrs.fillOpacity,\n      strokeOpacity = attrs.strokeOpacity,\n      lineWidth = attrs.lineWidth;\n    var el = this.get('el');\n    if (this.canFill) {\n      // 初次渲染和更新渲染的逻辑有所不同: 初次渲染值为空时，需要设置为 none，否则就会是黑色，而更新渲染则不需要\n      if (!targetAttrs) {\n        this._setColor(context, 'fill', fill || fillStyle);\n      } else if ('fill' in attrs) {\n        this._setColor(context, 'fill', fill);\n      } else if ('fillStyle' in attrs) {\n        // compatible with fillStyle\n        this._setColor(context, 'fill', fillStyle);\n      }\n      if (fillOpacity) {\n        el.setAttribute(SVG_ATTR_MAP['fillOpacity'], fillOpacity);\n      }\n    }\n    if (this.canStroke && lineWidth > 0) {\n      if (!targetAttrs) {\n        this._setColor(context, 'stroke', stroke || strokeStyle);\n      } else if ('stroke' in attrs) {\n        this._setColor(context, 'stroke', stroke);\n      } else if ('strokeStyle' in attrs) {\n        // compatible with strokeStyle\n        this._setColor(context, 'stroke', strokeStyle);\n      }\n      if (strokeOpacity) {\n        el.setAttribute(SVG_ATTR_MAP['strokeOpacity'], strokeOpacity);\n      }\n      if (lineWidth) {\n        el.setAttribute(SVG_ATTR_MAP['lineWidth'], lineWidth);\n      }\n    }\n  };\n  ShapeBase.prototype._setColor = function (context, attr, value) {\n    var el = this.get('el');\n    if (!value) {\n      // need to set `none` to avoid default value\n      el.setAttribute(SVG_ATTR_MAP[attr], 'none');\n      return;\n    }\n    value = value.trim();\n    if (/^[r,R,L,l]{1}[\\s]*\\(/.test(value)) {\n      var id = context.find('gradient', value);\n      if (!id) {\n        id = context.addGradient(value);\n      }\n      el.setAttribute(SVG_ATTR_MAP[attr], \"url(#\" + id + \")\");\n    } else if (/^[p,P]{1}[\\s]*\\(/.test(value)) {\n      var id = context.find('pattern', value);\n      if (!id) {\n        id = context.addPattern(value);\n      }\n      el.setAttribute(SVG_ATTR_MAP[attr], \"url(#\" + id + \")\");\n    } else {\n      el.setAttribute(SVG_ATTR_MAP[attr], value);\n    }\n  };\n  ShapeBase.prototype.shadow = function (context, targetAttrs) {\n    var attrs = this.attr();\n    var _a = targetAttrs || attrs,\n      shadowOffsetX = _a.shadowOffsetX,\n      shadowOffsetY = _a.shadowOffsetY,\n      shadowBlur = _a.shadowBlur,\n      shadowColor = _a.shadowColor;\n    if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {\n      setShadow(this, context);\n    }\n  };\n  ShapeBase.prototype.transform = function (targetAttrs) {\n    var attrs = this.attr();\n    var matrix = (targetAttrs || attrs).matrix;\n    if (matrix) {\n      setTransform(this);\n    }\n  };\n  ShapeBase.prototype.isInShape = function (refX, refY) {\n    return this.isPointInPath(refX, refY);\n  };\n  ShapeBase.prototype.isPointInPath = function (refX, refY) {\n    var el = this.get('el');\n    var canvas = this.get('canvas');\n    var bbox = canvas.get('el').getBoundingClientRect();\n    var clientX = refX + bbox.left;\n    var clientY = refY + bbox.top;\n    var element = document.elementFromPoint(clientX, clientY);\n    if (element && element.isEqualNode(el)) {\n      return true;\n    }\n    return false;\n  };\n  /**\n   * 获取线拾取的宽度\n   * @returns {number} 线的拾取宽度\n   */\n  ShapeBase.prototype.getHitLineWidth = function () {\n    var _a = this.attrs,\n      lineWidth = _a.lineWidth,\n      lineAppendWidth = _a.lineAppendWidth;\n    if (this.isStroke()) {\n      return lineWidth + lineAppendWidth;\n    }\n    return 0;\n  };\n  return ShapeBase;\n}(AbstractShape);\nexport default ShapeBase;","map":{"version":3,"mappings":"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","names":["AbstractShape","setShadow","setTransform","setClip","createDom","refreshElement","SVG_ATTR_MAP","Shape","Group","getBBoxMethod","__extends","_this","ShapeBase","attrs","_super","getDefaultAttrs","lineWidth","lineAppendWidth","strokeOpacity","fillOpacity","targetAttrs","afterAttrsChange","canvas","get","context","draw","changeType","el","bbox","getBBox","bboxMethod","y","width","height","getHitLineWidth","halfWidth","minX","x","minY","maxX","maxY","attr","fill","fillStyle","isClipShape","canFill","stroke","strokeStyle","canStroke","parentNode","removeChild","createPath","shadow","strokeAndFill","transform","_setColor","setAttribute","value","trim","test","id","find","addGradient","addPattern","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","matrix","refX","refY","isPointInPath","getBoundingClientRect","clientX","left","clientY","top","element","document","elementFromPoint","isEqualNode","isStroke"],"sources":["C:\\Users\\sandeep dangi\\OneDrive\\Desktop\\6th sem\\3rd sem\\company que\\react project\\admin-app\\node_modules\\@antv\\g-svg\\src\\shape\\base.ts"],"sourcesContent":["import { AbstractShape } from '@antv/g-base';\nimport { ShapeAttrs, ChangeType, BBox } from '@antv/g-base';\nimport { IShape } from '../interfaces';\nimport Defs from '../defs';\nimport { setShadow, setTransform, setClip } from '../util/svg';\nimport { createDom } from '../util/dom';\nimport { refreshElement } from '../util/draw';\nimport { SVG_ATTR_MAP } from '../constant';\nimport * as Shape from './index';\nimport Group from '../group';\nimport { getBBoxMethod } from '@antv/g-base';\n\nclass ShapeBase extends AbstractShape implements IShape {\n  type: string = 'svg';\n  canFill: boolean = false;\n  canStroke: boolean = false;\n\n  getDefaultAttrs() {\n    const attrs = super.getDefaultAttrs();\n    // 设置默认值\n    return {\n      ...attrs,\n      lineWidth: 1,\n      lineAppendWidth: 0,\n      strokeOpacity: 1,\n      fillOpacity: 1,\n    };\n  }\n\n  // 覆盖基类的 afterAttrsChange 方法\n  afterAttrsChange(targetAttrs: ShapeAttrs) {\n    super.afterAttrsChange(targetAttrs);\n    const canvas = this.get('canvas');\n    // 只有挂载到画布下，才对元素进行实际渲染\n    if (canvas && canvas.get('autoDraw')) {\n      const context = canvas.get('context');\n      this.draw(context, targetAttrs);\n    }\n  }\n\n  getShapeBase() {\n    return Shape;\n  }\n\n  getGroupBase() {\n    return Group;\n  }\n\n  /**\n   * 一些方法调用会引起画布变化\n   * @param {ChangeType} changeType 改变的类型\n   */\n  onCanvasChange(changeType: ChangeType) {\n    refreshElement(this, changeType);\n  }\n\n  calculateBBox(): BBox {\n    const el = this.get('el');\n    let bbox = null;\n    // 包围盒计算依赖于绘制，如果还没有生成对应的 Dom 元素，则包围盒的长宽均为 0\n    if (el) {\n      bbox = el.getBBox();\n    } else {\n      const bboxMethod = getBBoxMethod(this.get('type'));\n      if (bboxMethod) {\n        bbox = bboxMethod(this);\n      }\n    }\n    if (bbox) {\n      const { x, y, width, height } = bbox;\n      const lineWidth = this.getHitLineWidth();\n      const halfWidth = lineWidth / 2;\n      const minX = x - halfWidth;\n      const minY = y - halfWidth;\n      const maxX = x + width + halfWidth;\n      const maxY = y + height + halfWidth;\n      return {\n        x: minX,\n        y: minY,\n        minX,\n        minY,\n        maxX,\n        maxY,\n        width: width + lineWidth,\n        height: height + lineWidth,\n      };\n    }\n    return {\n      x: 0,\n      y: 0,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width: 0,\n      height: 0,\n    };\n  }\n\n  isFill() {\n    const { fill, fillStyle } = this.attr();\n    return (fill || fillStyle || this.isClipShape()) && this.canFill;\n  }\n\n  isStroke() {\n    const { stroke, strokeStyle } = this.attr();\n    return (stroke || strokeStyle) && this.canStroke;\n  }\n\n  draw(context, targetAttrs) {\n    const el = this.get('el');\n    if (this.get('destroyed')) {\n      if (el) {\n        el.parentNode.removeChild(el);\n      }\n    } else {\n      if (!el) {\n        createDom(this);\n      }\n      setClip(this, context);\n      this.createPath(context, targetAttrs);\n      this.shadow(context, targetAttrs);\n      this.strokeAndFill(context, targetAttrs);\n      this.transform(targetAttrs);\n    }\n  }\n\n  /**\n   * @protected\n   * 绘制图形的路径\n   * @param {Defs} context 上下文\n   * @param {ShapeAttrs} targetAttrs 渲染的目标属性\n   */\n  createPath(context: Defs, targetAttrs?: ShapeAttrs) {}\n\n  // stroke and fill\n  strokeAndFill(context, targetAttrs?) {\n    const attrs = targetAttrs || this.attr();\n    const { fill, fillStyle, stroke, strokeStyle, fillOpacity, strokeOpacity, lineWidth } = attrs;\n    const el = this.get('el');\n\n    if (this.canFill) {\n      // 初次渲染和更新渲染的逻辑有所不同: 初次渲染值为空时，需要设置为 none，否则就会是黑色，而更新渲染则不需要\n      if (!targetAttrs) {\n        this._setColor(context, 'fill', fill || fillStyle);\n      } else if ('fill' in attrs) {\n        this._setColor(context, 'fill', fill);\n      } else if ('fillStyle' in attrs) {\n        // compatible with fillStyle\n        this._setColor(context, 'fill', fillStyle);\n      }\n      if (fillOpacity) {\n        el.setAttribute(SVG_ATTR_MAP['fillOpacity'], fillOpacity);\n      }\n    }\n\n    if (this.canStroke && lineWidth > 0) {\n      if (!targetAttrs) {\n        this._setColor(context, 'stroke', stroke || strokeStyle);\n      } else if ('stroke' in attrs) {\n        this._setColor(context, 'stroke', stroke);\n      } else if ('strokeStyle' in attrs) {\n        // compatible with strokeStyle\n        this._setColor(context, 'stroke', strokeStyle);\n      }\n      if (strokeOpacity) {\n        el.setAttribute(SVG_ATTR_MAP['strokeOpacity'], strokeOpacity);\n      }\n      if (lineWidth) {\n        el.setAttribute(SVG_ATTR_MAP['lineWidth'], lineWidth);\n      }\n    }\n  }\n\n  _setColor(context, attr, value) {\n    const el = this.get('el');\n    if (!value) {\n      // need to set `none` to avoid default value\n      el.setAttribute(SVG_ATTR_MAP[attr], 'none');\n      return;\n    }\n    value = value.trim();\n    if (/^[r,R,L,l]{1}[\\s]*\\(/.test(value)) {\n      let id = context.find('gradient', value);\n      if (!id) {\n        id = context.addGradient(value);\n      }\n      el.setAttribute(SVG_ATTR_MAP[attr], `url(#${id})`);\n    } else if (/^[p,P]{1}[\\s]*\\(/.test(value)) {\n      let id = context.find('pattern', value);\n      if (!id) {\n        id = context.addPattern(value);\n      }\n      el.setAttribute(SVG_ATTR_MAP[attr], `url(#${id})`);\n    } else {\n      el.setAttribute(SVG_ATTR_MAP[attr], value);\n    }\n  }\n\n  shadow(context, targetAttrs?) {\n    const attrs = this.attr();\n    const { shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor } = targetAttrs || attrs;\n    if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {\n      setShadow(this, context);\n    }\n  }\n\n  transform(targetAttrs?) {\n    const attrs = this.attr();\n    const { matrix } = targetAttrs || attrs;\n    if (matrix) {\n      setTransform(this);\n    }\n  }\n\n  isInShape(refX: number, refY: number): boolean {\n    return this.isPointInPath(refX, refY);\n  }\n\n  isPointInPath(refX: number, refY: number): boolean {\n    const el = this.get('el');\n    const canvas = this.get('canvas');\n    const bbox = canvas.get('el').getBoundingClientRect();\n    const clientX = refX + bbox.left;\n    const clientY = refY + bbox.top;\n    const element = document.elementFromPoint(clientX, clientY);\n    if (element && element.isEqualNode(el)) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * 获取线拾取的宽度\n   * @returns {number} 线的拾取宽度\n   */\n  getHitLineWidth() {\n    const { lineWidth, lineAppendWidth } = this.attrs;\n    if (this.isStroke()) {\n      return lineWidth + lineAppendWidth;\n    }\n    return 0;\n  }\n}\n\nexport default ShapeBase;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}