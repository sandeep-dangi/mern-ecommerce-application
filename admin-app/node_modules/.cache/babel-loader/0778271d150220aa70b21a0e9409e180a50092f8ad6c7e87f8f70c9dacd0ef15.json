{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport { ext, mat3, vec3 } from '@antv/matrix-util';\nimport { assign } from '@antv/util';\n/**\n * Coordinate Base Class\n */\nvar Coordinate = /** @class */function () {\n  function Coordinate(cfg) {\n    // 自身属性\n    this.type = 'coordinate';\n    this.isRect = false;\n    this.isHelix = false;\n    this.isPolar = false;\n    this.isReflectX = false;\n    this.isReflectY = false;\n    var start = cfg.start,\n      end = cfg.end,\n      _a = cfg.matrix,\n      matrix = _a === void 0 ? [1, 0, 0, 0, 1, 0, 0, 0, 1] : _a,\n      _b = cfg.isTransposed,\n      isTransposed = _b === void 0 ? false : _b;\n    this.start = start;\n    this.end = end;\n    this.matrix = matrix;\n    this.originalMatrix = __spreadArray([], matrix); // 去除引用\n    this.isTransposed = isTransposed;\n  }\n  /**\n   * 初始化流程\n   */\n  Coordinate.prototype.initial = function () {\n    // center、width、height\n    this.center = {\n      x: (this.start.x + this.end.x) / 2,\n      y: (this.start.y + this.end.y) / 2\n    };\n    this.width = Math.abs(this.end.x - this.start.x);\n    this.height = Math.abs(this.end.y - this.start.y);\n  };\n  /**\n   * 更新配置\n   * @param cfg\n   */\n  Coordinate.prototype.update = function (cfg) {\n    assign(this, cfg);\n    this.initial();\n  };\n  Coordinate.prototype.convertDim = function (percent, dim) {\n    var _a;\n    var _b = this[dim],\n      start = _b.start,\n      end = _b.end;\n    // 交换\n    if (this.isReflect(dim)) {\n      _a = [end, start], start = _a[0], end = _a[1];\n    }\n    return start + percent * (end - start);\n  };\n  Coordinate.prototype.invertDim = function (value, dim) {\n    var _a;\n    var _b = this[dim],\n      start = _b.start,\n      end = _b.end;\n    // 交换\n    if (this.isReflect(dim)) {\n      _a = [end, start], start = _a[0], end = _a[1];\n    }\n    return (value - start) / (end - start);\n  };\n  /**\n   * 将坐标点进行矩阵变换\n   * @param x   对应 x 轴画布坐标\n   * @param y   对应 y 轴画布坐标\n   * @param tag 默认为 0，可取值 0, 1\n   * @return    返回变换后的三阶向量 [x, y, z]\n   */\n  Coordinate.prototype.applyMatrix = function (x, y, tag) {\n    if (tag === void 0) {\n      tag = 0;\n    }\n    var matrix = this.matrix;\n    var vector = [x, y, tag];\n    vec3.transformMat3(vector, vector, matrix);\n    return vector;\n  };\n  /**\n   * 将坐标点进行矩阵逆变换\n   * @param x   对应 x 轴画布坐标\n   * @param y   对应 y 轴画布坐标\n   * @param tag 默认为 0，可取值 0, 1\n   * @return    返回矩阵逆变换后的三阶向量 [x, y, z]\n   */\n  Coordinate.prototype.invertMatrix = function (x, y, tag) {\n    if (tag === void 0) {\n      tag = 0;\n    }\n    var matrix = this.matrix;\n    var inverted = mat3.invert([0, 0, 0, 0, 0, 0, 0, 0, 0], matrix);\n    var vector = [x, y, tag];\n    if (inverted) {\n      // 如果为空则不进行矩阵变化，防止报错\n      vec3.transformMat3(vector, vector, inverted);\n    }\n    return vector;\n  };\n  /**\n   * 将归一化的坐标点数据转换为画布坐标，并根据坐标系当前矩阵进行变换\n   * @param point 归一化的坐标点\n   * @return      返回进行矩阵变换后的画布坐标\n   */\n  Coordinate.prototype.convert = function (point) {\n    var _a = this.convertPoint(point),\n      x = _a.x,\n      y = _a.y;\n    var vector = this.applyMatrix(x, y, 1);\n    return {\n      x: vector[0],\n      y: vector[1]\n    };\n  };\n  /**\n   * 将进行过矩阵变换画布坐标转换为归一化坐标\n   * @param point 画布坐标\n   * @return      返回归一化的坐标点\n   */\n  Coordinate.prototype.invert = function (point) {\n    var vector = this.invertMatrix(point.x, point.y, 1);\n    return this.invertPoint({\n      x: vector[0],\n      y: vector[1]\n    });\n  };\n  /**\n   * 坐标系旋转变换\n   * @param  radian 旋转弧度\n   * @return        返回坐标系对象\n   */\n  Coordinate.prototype.rotate = function (radian) {\n    var matrix = this.matrix;\n    var center = this.center;\n    ext.leftTranslate(matrix, matrix, [-center.x, -center.y]);\n    ext.leftRotate(matrix, matrix, radian);\n    ext.leftTranslate(matrix, matrix, [center.x, center.y]);\n    return this;\n  };\n  /**\n   * 坐标系反射变换\n   * @param dim 反射维度\n   * @return    返回坐标系对象\n   */\n  Coordinate.prototype.reflect = function (dim) {\n    if (dim === 'x') {\n      this.isReflectX = !this.isReflectX;\n    } else {\n      this.isReflectY = !this.isReflectY;\n    }\n    return this;\n  };\n  /**\n   * 坐标系比例变换\n   * @param s1 x 方向缩放比例\n   * @param s2 y 方向缩放比例\n   * @return     返回坐标系对象\n   */\n  Coordinate.prototype.scale = function (s1, s2) {\n    var matrix = this.matrix;\n    var center = this.center;\n    ext.leftTranslate(matrix, matrix, [-center.x, -center.y]);\n    ext.leftScale(matrix, matrix, [s1, s2]);\n    ext.leftTranslate(matrix, matrix, [center.x, center.y]);\n    return this;\n  };\n  /**\n   * 坐标系平移变换\n   * @param x x 方向平移像素\n   * @param y y 方向平移像素\n   * @return    返回坐标系对象\n   */\n  Coordinate.prototype.translate = function (x, y) {\n    var matrix = this.matrix;\n    ext.leftTranslate(matrix, matrix, [x, y]);\n    return this;\n  };\n  /**\n   * 将坐标系 x y 两个轴进行转置\n   * @return 返回坐标系对象\n   */\n  Coordinate.prototype.transpose = function () {\n    this.isTransposed = !this.isTransposed;\n    return this;\n  };\n  Coordinate.prototype.getCenter = function () {\n    return this.center;\n  };\n  Coordinate.prototype.getWidth = function () {\n    return this.width;\n  };\n  Coordinate.prototype.getHeight = function () {\n    return this.height;\n  };\n  Coordinate.prototype.getRadius = function () {\n    return this.radius;\n  };\n  /**\n   * whether has reflect\n   * @param dim\n   */\n  Coordinate.prototype.isReflect = function (dim) {\n    return dim === 'x' ? this.isReflectX : this.isReflectY;\n  };\n  /**\n   * 重置 matrix\n   * @param matrix 如果传入，则使用，否则使用构造函数中传入的默认 matrix\n   */\n  Coordinate.prototype.resetMatrix = function (matrix) {\n    // 去除引用关系\n    this.matrix = matrix ? matrix : __spreadArray([], this.originalMatrix);\n  };\n  return Coordinate;\n}();\nexport default Coordinate;","map":{"version":3,"mappings":"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","names":["ext","mat3","vec3","assign","cfg","end","_a","matrix","_b","isTransposed","start","originalMatrix","__spreadArray","Coordinate","center","x","y","width","Math","abs","height","initial","percent","dim","isReflect","value","tag","vector","transformMat3","inverted","invert","point","convertPoint","applyMatrix","invertMatrix","invertPoint","radian","leftTranslate","leftRotate","isReflectX","isReflectY","s1","s2","leftScale","radius"],"sources":["C:\\Users\\sandeep dangi\\OneDrive\\Desktop\\6th sem\\3rd sem\\company que\\react project\\mern\\admin-app\\node_modules\\@antv\\coord\\src\\coord\\base.ts"],"sourcesContent":["import { ext, mat3, vec3 } from '@antv/matrix-util';\nimport { assign } from '@antv/util';\nimport { CoordinateCfg, ICoordinate, Point, Range } from '../interface';\n\nexport type CoordinateCtor = new (cfg: any) => Coordinate;\nexport type Vector2 = [number, number];\nexport type Vector3 = [number, number, number];\nexport type Matrix3 = [number, number, number, number, number, number, number, number, number];\n\n/**\n * Coordinate Base Class\n */\nexport default abstract class Coordinate implements ICoordinate {\n  // 自身属性\n  public readonly type: string = 'coordinate';\n  public readonly isRect: boolean = false;\n  public readonly isHelix: boolean = false;\n  public readonly isPolar: boolean = false;\n\n  // 外部属性\n  public start: Point;\n  public end: Point;\n  public matrix: Matrix3;\n  public isTransposed: boolean;\n\n  // 极坐标下的属性\n  public startAngle: number;\n  public endAngle: number;\n  public innerRadius: number;\n  public radius: number;\n\n  public x: Range;\n  public y: Range;\n\n  // 计算属性，通过相应的 get 方法获取，所以使用 protected 访问修饰符\n  protected center: Point;\n  protected width: number;\n  protected height: number;\n  private isReflectX = false;\n  private isReflectY = false;\n  // 初始构造时候的 matrix，存储起来用于 reset\n  private originalMatrix: Matrix3;\n\n  constructor(cfg: CoordinateCfg) {\n    const { start, end, matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1], isTransposed = false } = cfg;\n    this.start = start;\n    this.end = end;\n    this.matrix = matrix as Matrix3;\n    this.originalMatrix = [...matrix] as Matrix3; // 去除引用\n    this.isTransposed = isTransposed;\n  }\n\n  /**\n   * 初始化流程\n   */\n  public initial() {\n    // center、width、height\n    this.center = {\n      x: (this.start.x + this.end.x) / 2,\n      y: (this.start.y + this.end.y) / 2,\n    };\n\n    this.width = Math.abs(this.end.x - this.start.x);\n    this.height = Math.abs(this.end.y - this.start.y);\n  }\n\n  /**\n   * 更新配置\n   * @param cfg\n   */\n  public update(cfg: CoordinateCfg) {\n    assign(this, cfg);\n    this.initial();\n  }\n\n  public convertDim(percent: number, dim: string): number {\n    let { start, end } = this[dim];\n\n    // 交换\n    if (this.isReflect(dim)) {\n      [start, end] = [end, start];\n    }\n\n    return start + percent * (end - start);\n  }\n\n  public invertDim(value: number, dim: string): number {\n    let { start, end } = this[dim];\n    // 交换\n    if (this.isReflect(dim)) {\n      [start, end] = [end, start];\n    }\n\n    return (value - start) / (end - start);\n  }\n\n  /**\n   * 将坐标点进行矩阵变换\n   * @param x   对应 x 轴画布坐标\n   * @param y   对应 y 轴画布坐标\n   * @param tag 默认为 0，可取值 0, 1\n   * @return    返回变换后的三阶向量 [x, y, z]\n   */\n  public applyMatrix(x: number, y: number, tag: number = 0): number[] {\n    const matrix = this.matrix;\n    const vector: Vector3 = [x, y, tag];\n    vec3.transformMat3(vector, vector, matrix);\n    return vector;\n  }\n\n  /**\n   * 将坐标点进行矩阵逆变换\n   * @param x   对应 x 轴画布坐标\n   * @param y   对应 y 轴画布坐标\n   * @param tag 默认为 0，可取值 0, 1\n   * @return    返回矩阵逆变换后的三阶向量 [x, y, z]\n   */\n  public invertMatrix(x: number, y: number, tag: number = 0): number[] {\n    const matrix = this.matrix;\n    const inverted = mat3.invert([0, 0, 0, 0, 0, 0, 0, 0, 0], matrix);\n    const vector: Vector3 = [x, y, tag];\n    if (inverted) {\n      // 如果为空则不进行矩阵变化，防止报错\n      vec3.transformMat3(vector, vector, inverted);\n    }\n    return vector;\n  }\n\n  /**\n   * 将归一化的坐标点数据转换为画布坐标，并根据坐标系当前矩阵进行变换\n   * @param point 归一化的坐标点\n   * @return      返回进行矩阵变换后的画布坐标\n   */\n  public convert(point: Point): Point {\n    const { x, y } = this.convertPoint(point);\n    const vector = this.applyMatrix(x, y, 1);\n    return {\n      x: vector[0],\n      y: vector[1],\n    };\n  }\n\n  /**\n   * 将进行过矩阵变换画布坐标转换为归一化坐标\n   * @param point 画布坐标\n   * @return      返回归一化的坐标点\n   */\n  public invert(point: Point): Point {\n    const vector = this.invertMatrix(point.x, point.y, 1);\n    return this.invertPoint({\n      x: vector[0],\n      y: vector[1],\n    });\n  }\n\n  /**\n   * 坐标系旋转变换\n   * @param  radian 旋转弧度\n   * @return        返回坐标系对象\n   */\n  public rotate(radian: number) {\n    const matrix = this.matrix;\n    const center = this.center;\n    ext.leftTranslate(matrix, matrix, [-center.x, -center.y]);\n    ext.leftRotate(matrix, matrix, radian);\n    ext.leftTranslate(matrix, matrix, [center.x, center.y]);\n    return this;\n  }\n\n  /**\n   * 坐标系反射变换\n   * @param dim 反射维度\n   * @return    返回坐标系对象\n   */\n  public reflect(dim: string) {\n    if (dim === 'x') {\n      this.isReflectX = !this.isReflectX;\n    } else {\n      this.isReflectY = !this.isReflectY;\n    }\n    return this;\n  }\n\n  /**\n   * 坐标系比例变换\n   * @param s1 x 方向缩放比例\n   * @param s2 y 方向缩放比例\n   * @return     返回坐标系对象\n   */\n  public scale(s1: number, s2: number) {\n    const matrix = this.matrix;\n    const center = this.center;\n    ext.leftTranslate(matrix, matrix, [-center.x, -center.y]);\n    ext.leftScale(matrix, matrix, [s1, s2]);\n    ext.leftTranslate(matrix, matrix, [center.x, center.y]);\n    return this;\n  }\n\n  /**\n   * 坐标系平移变换\n   * @param x x 方向平移像素\n   * @param y y 方向平移像素\n   * @return    返回坐标系对象\n   */\n  public translate(x: number, y: number) {\n    const matrix = this.matrix;\n    ext.leftTranslate(matrix, matrix, [x, y]);\n    return this;\n  }\n\n  /**\n   * 将坐标系 x y 两个轴进行转置\n   * @return 返回坐标系对象\n   */\n  public transpose() {\n    this.isTransposed = !this.isTransposed;\n    return this;\n  }\n\n  public getCenter(): Point {\n    return this.center;\n  }\n\n  public getWidth(): number {\n    return this.width;\n  }\n\n  public getHeight(): number {\n    return this.height;\n  }\n\n  public getRadius(): number {\n    return this.radius;\n  }\n\n  /**\n   * whether has reflect\n   * @param dim\n   */\n  public isReflect(dim: string): boolean {\n    return dim === 'x' ? this.isReflectX : this.isReflectY;\n  }\n\n  /**\n   * 重置 matrix\n   * @param matrix 如果传入，则使用，否则使用构造函数中传入的默认 matrix\n   */\n  public resetMatrix(matrix?: Matrix3) {\n    // 去除引用关系\n    this.matrix = matrix ? matrix : ([...this.originalMatrix] as Matrix3);\n  }\n\n  /**\n   * 将归一化的坐标点数据转换为画布坐标\n   * @param point\n   */\n  public abstract convertPoint(point: Point): Point;\n\n  /**\n   * 画布坐标转换为归一化的坐标点数据\n   * @param point\n   */\n  public abstract invertPoint(point: Point): Point;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}